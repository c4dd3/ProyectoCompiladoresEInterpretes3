/* ====== Parser para Pascal ABS - Con Recuperacion de Errores ====== */
package parser;
import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.List;
import parser.SymbolTable;

parser code {:
    // Para guardar info de cada identificador en una declaracion
    public static class IdInfo {
        public String name;
        public int line;

        public IdInfo(String name, int line) {
            this.name = name;
            this.line = line;
        }

        
    }

     public static class ParamInfo {
        public String name;
        public String type;
        public int line;

        public ParamInfo(String name, String type, int line) {
            this.name = name;
            this.type = type;
            this.line = line;
        }
    
    }

    // Lista para almacenar errores sintacticos
    private ArrayList<String> erroresSintacticos = new ArrayList<>();
    private int errorCount = 0;
    private static final int MAX_ERRORS = 50; // Limite de errores antes de abortar
    
    public ArrayList<String> getErroresSintacticos() {
        return erroresSintacticos;
    }
    
    // Metodo mejorado para reportar errores sintacticos con contexto
    public void report_error(String message, Object info) {
        if (errorCount >= MAX_ERRORS) {
            return; // Evitar reportar demasiados errores
        }
        
        if (info instanceof Symbol) {
            Symbol s = (Symbol)info;
            int line = (s.left >= 0 ? s.left + 1 : 1);
            int column = (s.right >= 0 ? s.right + 1 : 1);
            
            String errorMsg = String.format("Linea %d, Columna %d: %s", line, column, message);
            
            // Evitar errores duplicados
            if (!erroresSintacticos.contains(errorMsg)) {
                erroresSintacticos.add(errorMsg);
                errorCount++;
            }
        } else {
            String errorMsg = "Error sintactico: " + message;
            erroresSintacticos.add(errorMsg);
            errorCount++;
        }
    }
    
    public void report_fatal_error(String message, Object info) {
        report_error("Error fatal: " + message, info);
    }
    
    // Metodo mejorado con mensajes mas descriptivos
    public void syntax_error(Symbol cur_token) {
        String tokenValue = (cur_token.value != null ? cur_token.value.toString() : "fin de archivo");
        String errorMsg = String.format(
            "Token inesperado '%s'. Verifique la sintaxis del programa", 
            tokenValue
        );
        report_error(errorMsg, cur_token);
    }
    
    public void unrecovered_syntax_error(Symbol cur_token) {
        String tokenValue = (cur_token.value != null ? cur_token.value.toString() : "fin de archivo");
        String errorMsg = String.format(
            "Error de sintaxis irrecuperable en '%s'. El analisis no puede continuar desde este punto", 
            tokenValue
        );
        report_error(errorMsg, cur_token);
    }
    
    // Metodo auxiliar para reportar errores especificos
    public void reportarErrorEspecifico(String contexto, String esperado, String encontrado, Symbol s) {
        String errorMsg = String.format(
            "%s: Se esperaba %s, pero se encontro '%s'",
            contexto, esperado, encontrado
        );
        report_error(errorMsg, s);
    }

:}

/* ========== TODOS LOS TERMINALES DEL JFLEX ========== */
terminal 
    /* Palabras reservadas COMPLETAS */
    ABSOLUTE, AND, ARRAY, ASM, BEGIN, CASE, CONST, CONSTRUCTOR,
    DESTRUCTOR, DIV, DO, DOWNTO, ELSE, END, EXTERNAL, FILE, FOR, 
    FORWARD, FUNCTION, GOTO, IF, IMPLEMENTATION, IN, INLINE, INTERFACE, 
    INTERRUPT, LABEL, MOD, NIL, NOT, OBJECT, OF, OR, PACKED, PRIVATE, 
    PROCEDURE, PROGRAM, RECORD, REPEAT, SET, SHL, SHR, STRING, THEN, 
    TO, TYPE, UNIT, UNTIL, USES, VAR, VIRTUAL, WHILE, WITH, XOR,
    INT, CHAR, READ, REAL, WRITE,

    /* Operadores y simbolos COMPLETOS */
    MAS, MENOS, POR, DIVISION, INCREMENTO, DECREMENTO, POTENCIA,
    IGUAL, DIFERENTE, MENOR, MAYOR, MENOR_IGUAL, MAYOR_IGUAL,
    ASIGNACION, PUNTO_COMA, COMA, DOS_PUNTOS, PARENTESIS_IZQ, 
    PARENTESIS_DER, CORCHETE_IZQ, CORCHETE_DER, PUNTO, PUNTERO,
    
    /* Literales COMPLETOS */
    LIT_ENTERO, LIT_REAL, LIT_OCTAL, LIT_HEX, LIT_STRING, LIT_CHAR;
    
    /* Identificadores */
terminal String IDENTIFICADOR;

/* ========== REGLAS DE PRODUCCION - NON TERMINALS ========== */
non terminal
    // Estructura del Programa
    inicio,
    programa,
    
    // Declaracion de Variables
    variables_globales,
    lista_declaraciones_globales,
    declaracion_variable_global,
    
    // Declaracion de Funciones y Procedures
    funciones_globales,
    funcion_global,
    procedure_global,
    cuerpo_funcion,
    cuerpo_procedure,
    bloque_funcion,
    bloque_procedure,
    retorno,
    
    // Sentencias
    sentencias,
    sentencia,
    sentencias_main,
    sentencia_main,
    
    // Expresiones Aritmeticas
    expresion,
    termino,
    factor,
    
    // Expresiones Booleanas (Condiciones)
    condicion,
    condicion_and,
    condicion_not,
    condicion_relacional,
    
    // Estructuras de Control
    estructura_control,
    while_stmt,
    for_stmt,
    if_stmt,
    
    // READ y WRITE
    read_stmt,
    write_stmt,
    
    // Llamadas a funciones
    llamada_funcion,
    lista_expresiones,
    mas_expresiones,
    
    // Main
    cuerpo_main;
  
// Tipados para semántica
non terminal java.util.List<IdInfo> lista_identificadores, mas_identificadores;
non terminal String tipo;
non terminal java.util.List<ParamInfo> parametros, mas_parametros;

/* ========== PRECEDENCIAS DE OPERADORES ========== */
// Precedencia de operadores booleanos (menor a mayor)
precedence left OR;
precedence left AND;
precedence right NOT;

// Precedencia de operadores relacionales
precedence left IGUAL, DIFERENTE, MENOR, MAYOR, MENOR_IGUAL, MAYOR_IGUAL;

// Precedencia de operadores aritmeticos (menor a mayor)
precedence left MAS, MENOS;
precedence left POR, DIVISION, DIV, MOD;
precedence right INCREMENTO, DECREMENTO;
precedence left POTENCIA;

/* ========== INICIO ========== */
start with inicio;

inicio ::= programa;

/* ========== Estructura del Programa ========== */
programa ::= PROGRAM IDENTIFICADOR variables_globales funciones_globales cuerpo_main
           | PROGRAM IDENTIFICADOR variables_globales funciones_globales cuerpo_main PUNTO
           | PROGRAM error variables_globales funciones_globales cuerpo_main
             {: parser.report_error("Falta el nombre del programa despues de PROGRAM", null); :}
           | error
             {: parser.report_error("Falta palabra clave PROGRAM al inicio del archivo", null); :}
           ;

/* ========== Declaracion de Variables Globales ========== */
variables_globales ::= VAR lista_declaraciones_globales
                     | /* vacío */   
                     ;

lista_declaraciones_globales ::= declaracion_variable_global
                                | lista_declaraciones_globales declaracion_variable_global
                                ;

declaracion_variable_global ::= lista_identificadores:ids DOS_PUNTOS tipo:t PUNTO_COMA
    {:
        // Para cada identificador declarado, lo agregamos a la tabla de símbolos
        for (IdInfo id : ids) {
            boolean ok = SymbolTable.addVariable(id.name, t, id.line);
            if (!ok) {
                // Variable doblemente definida en el mismo ámbito
                SemanticAnalyzer.addError(
                    id.line,
                    "Variable '" + id.name + "' ya esta definida en el ambito " + SymbolTable.getCurrentScope(),
                    "DOBLE_DEFINICION"
                );
            }
        }
    :}
    | lista_identificadores DOS_PUNTOS error PUNTO_COMA
      {: parser.report_error("Tipo de dato invalido o faltante en declaracion de variable. Use: INT, REAL, STRING o CHAR", null); :}
    | lista_identificadores error tipo PUNTO_COMA
      {: parser.report_error("Falta ':' en declaracion de variable. Formato correcto: 'variable : TIPO;'", null); :}
    ;

lista_identificadores ::= IDENTIFICADOR:id mas_identificadores:resto
    {:
        java.util.List<IdInfo> list = new java.util.ArrayList<>();

        // Symbol completo del primer IDENTIFICADOR
        // Producción: IDENTIFICADOR mas_identificadores  → largo = 2
        // Stack: top-1 = IDENTIFICADOR, top-0 = mas_identificadores
        java_cup.runtime.Symbol idSym =
            (java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1);

        String name = id; // el lexema (String, porque terminal String IDENTIFICADOR)
        int line = (idSym.left >= 0 ? idSym.left + 1 : 1);

        list.add(new IdInfo(name, line));

        java.util.List<IdInfo> tail = resto; // ya está tipado como List<IdInfo>
        if (tail != null) list.addAll(tail);

        RESULT = list;
    :}
    ;

mas_identificadores ::= COMA IDENTIFICADOR:id mas_identificadores:resto
    {:
        java.util.List<IdInfo> list = new java.util.ArrayList<>();

        // Producción: COMA IDENTIFICADOR mas_identificadores  → largo = 3
        // Stack:
        //   top-2 = COMA
        //   top-1 = IDENTIFICADOR
        //   top-0 = mas_identificadores
        java_cup.runtime.Symbol idSym =
            (java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1);

        String name = id;
        int line = (idSym.left >= 0 ? idSym.left + 1 : 1);

        list.add(new IdInfo(name, line));

        java.util.List<IdInfo> tail = resto;
        if (tail != null) list.addAll(tail);

        RESULT = list;
    :}
    | /* vacío */
    {:
        RESULT = new java.util.ArrayList<IdInfo>();
    :}
    ;

/* ========== Declaracion de Funciones y Procedures ========== */
funciones_globales ::= funcion_global funciones_globales
                     | procedure_global funciones_globales
                     | /* epsilon */
                     ;

/* ========== FUNCTION ========== */
funcion_global ::=
    FUNCTION IDENTIFICADOR:id PARENTESIS_IZQ parametros:plist PARENTESIS_DER DOS_PUNTOS tipo:t
    {:
        // FUNCTION (top-6), IDENTIFICADOR (top-5), '(' (top-4),
        // parametros (top-3), ')' (top-2), ':' (top-1), tipo (top-0)
        java_cup.runtime.Symbol idSym =
            (java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5);
        int line = (idSym.left >= 0 ? idSym.left + 1 : 1);

        // Convertir ParamInfo -> listas de nombres y tipos
        java.util.List<String> paramNames = new java.util.ArrayList<>();
        java.util.List<String> paramTypes = new java.util.ArrayList<>();
        for (ParamInfo p : plist) {
            paramNames.add(p.name);
            paramTypes.add(p.type);
        }

        boolean ok = SymbolTable.addFunction(id, line, paramNames, paramTypes, t);
        if (!ok) {
            SemanticAnalyzer.addError(
                line,
                "Funcion '" + id + "' ya esta definida en el ambito GLOBAL",
                "DOBLE_DEFINICION_FUNCION"
            );
        }

        // Abrir scope para la función
        SymbolTable.enterScope(id);

        // Insertar parámetros como variables del scope de la función
        for (ParamInfo p : plist) {
            boolean okVar = SymbolTable.addVariable(p.name, p.type, p.line);
            if (!okVar) {
                SemanticAnalyzer.addError(
                    p.line,
                    "Parametro '" + p.name + "' ya esta definido en el ambito de la funcion '" + id + "'",
                    "DOBLE_DEFINICION"
                );
            }
        }
    :}
    cuerpo_funcion
    {:
        // Salir del scope de la función
        SymbolTable.exitScope();
    :}
  | FUNCTION IDENTIFICADOR PARENTESIS_IZQ parametros error DOS_PUNTOS tipo cuerpo_funcion
    {: parser.report_error("Falta ')' en declaracion de parametros de funcion", null); :}
  | FUNCTION IDENTIFICADOR PARENTESIS_IZQ parametros PARENTESIS_DER error tipo cuerpo_funcion
    {: parser.report_error("Falta ':' antes del tipo de retorno de funcion", null); :}
  | FUNCTION IDENTIFICADOR PARENTESIS_IZQ parametros PARENTESIS_DER DOS_PUNTOS error cuerpo_funcion
    {: parser.report_error("Tipo de retorno invalido en funcion. Use: INT, REAL, STRING o CHAR", null); :}
  | FUNCTION IDENTIFICADOR PARENTESIS_IZQ parametros PARENTESIS_DER error cuerpo_funcion
    {: parser.report_error("Falta ':' y tipo de retorno en declaracion de funcion", null); :}
  | FUNCTION IDENTIFICADOR PARENTESIS_IZQ parametros PARENTESIS_DER DOS_PUNTOS tipo error END
    {: parser.report_error("Falta BEGIN en cuerpo de funcion", null); :}
  | FUNCTION error cuerpo_funcion
    {: parser.report_error("Error en declaracion de funcion. Formato: 'FUNCTION nombre(parametros): TIPO BEGIN ... END'", null); :}
  ;

parametros ::= tipo:t IDENTIFICADOR:id mas_parametros:resto
    {:
        java.util.List<ParamInfo> list = new java.util.ArrayList<>();

        // Producción: tipo IDENTIFICADOR mas_parametros  (longitud 3)
        // Stack: top-2 = tipo, top-1 = IDENTIFICADOR, top-0 = mas_parametros
        java_cup.runtime.Symbol idSym =
            (java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1);

        int line = (idSym.left >= 0 ? idSym.left + 1 : 1);

        list.add(new ParamInfo(id, t, line));

        java.util.List<ParamInfo> tail = resto;
        if (tail != null) list.addAll(tail);

        RESULT = list;
    :}
  | /* epsilon */
    {:
        RESULT = new java.util.ArrayList<ParamInfo>();
    :}
  ;

mas_parametros ::= COMA tipo:t IDENTIFICADOR:id mas_parametros:resto
    {:
        java.util.List<ParamInfo> list = new java.util.ArrayList<>();

        // Producción: COMA tipo IDENTIFICADOR mas_parametros (longitud 4)
        // Stack: top-3 = COMA, top-2 = tipo, top-1 = IDENTIFICADOR, top-0 = mas_parametros
        java_cup.runtime.Symbol idSym =
            (java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-1);

        int line = (idSym.left >= 0 ? idSym.left + 1 : 1);

        list.add(new ParamInfo(id, t, line));

        java.util.List<ParamInfo> tail = resto;
        if (tail != null) list.addAll(tail);

        RESULT = list;
    :}
  | /* epsilon */
    {:
        RESULT = new java.util.ArrayList<ParamInfo>();
    :}
  ;

cuerpo_funcion ::= BEGIN bloque_funcion END 
                  | VAR lista_declaraciones_globales BEGIN bloque_funcion END
                 ;

bloque_funcion ::= sentencias retorno
                 | retorno
                 | sentencias error
                   {: parser.report_error("Falta RETURN en cuerpo de funcion", null); :}
                 | error 
                   {: parser.report_error("Falta RETURN en cuerpo de funcion", null); :}
                 ;

retorno ::= IDENTIFICADOR:id ASIGNACION expresion PUNTO_COMA
    {:
        // Línea del identificador del "retorno"
        java_cup.runtime.Symbol idSym =
            (java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3);
        int line = (idSym.left >= 0 ? idSym.left + 1 : 1);

        // Resultado de la expresión de retorno
        SemanticStack.StackEntry expr = null;
        if (SemanticStack.size() > 0) {
            expr = SemanticStack.pop();
        }

        // Nombre del scope actual (debería ser el nombre de la función)
        String currentScope = SymbolTable.getCurrentScope();

        // 1) Verificar que se está retornando a la función correcta
        if (!id.equals(currentScope)) {
            SemanticAnalyzer.addError(
                line,
                "El retorno debe asignarse al identificador de la funcion '" +
                currentScope + "', no a '" + id + "'",
                "RETORNO_INVALIDO"
            );
        }

        // 2) Verificar tipo de retorno vs tipo de la función
        SymbolTable.Symbol funSym = SymbolTable.lookupInScope(currentScope, "GLOBAL");
        if (funSym != null && expr != null && !expr.type.equals("ERROR")) {

            boolean compatible =
                   funSym.type.equals(expr.type)
                || (funSym.type.equals("REAL") && expr.type.equals("INT"));

            if (!compatible) {
                SemanticAnalyzer.addError(
                    line,
                    "Tipo de retorno incompatible en funcion '" + currentScope +
                    "': se esperaba " + funSym.type +
                    " pero se obtuvo " + expr.type,
                    "TIPO_RETORNO_INCOMPATIBLE"
                );
            } else {
                // Código intermedio para el retorno: nombreFuncion = valor
                CodeGenerator.emitCode(currentScope + " = " + expr.value);
            }
        }
    :}
          ;

/* ========== PROCEDURE ========== */
procedure_global ::=
    PROCEDURE IDENTIFICADOR:id PARENTESIS_IZQ parametros:plist PARENTESIS_DER DOS_PUNTOS error tipo cuerpo_procedure
      {: parser.report_error("Un procedimiento no debe tener tipo de retorno. Use FUNCTION si requiere devolver un valor", null); :}
  | PROCEDURE IDENTIFICADOR:id PARENTESIS_IZQ parametros:plist PARENTESIS_DER DOS_PUNTOS error cuerpo_procedure
      {: parser.report_error("Un procedimiento no debe tener tipo de retorno. Use FUNCTION si requiere devolver un valor", null); :}
  | PROCEDURE IDENTIFICADOR:id PARENTESIS_IZQ parametros:plist PARENTESIS_DER
    {:
        java_cup.runtime.Symbol idSym =
            (java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3);
        int line = (idSym.left >= 0 ? idSym.left + 1 : 1);

        java.util.List<String> paramNames = new java.util.ArrayList<>();
        java.util.List<String> paramTypes = new java.util.ArrayList<>();
        for (ParamInfo p : plist) {
            paramNames.add(p.name);
            paramTypes.add(p.type);
        }

        boolean ok = SymbolTable.addProcedure(id, line, paramNames, paramTypes);
        if (!ok) {
            SemanticAnalyzer.addError(
                line,
                "Procedimiento '" + id + "' ya esta definido en el ambito GLOBAL",
                "DOBLE_DEFINICION_PROCEDURE"
            );
        }

        SymbolTable.enterScope(id);

        // Insertar parámetros como variables del scope del procedimiento
        for (ParamInfo p : plist) {
            boolean okVar = SymbolTable.addVariable(p.name, p.type, p.line);
            if (!okVar) {
                SemanticAnalyzer.addError(
                    p.line,
                    "Parametro '" + p.name + "' ya esta definido en el ambito del procedimiento '" + id + "'",
                    "DOBLE_DEFINICION"
                );
            }
        }
    :}
    cuerpo_procedure
    {:
        SymbolTable.exitScope();
    :}
  | PROCEDURE IDENTIFICADOR PARENTESIS_IZQ parametros error cuerpo_procedure
  | PROCEDURE IDENTIFICADOR PARENTESIS_IZQ parametros PARENTESIS_DER error END
  | PROCEDURE error cuerpo_procedure
  ;

cuerpo_procedure ::= BEGIN bloque_procedure END
                    | VAR lista_declaraciones_globales BEGIN bloque_procedure END
                   ;

bloque_procedure ::= sentencias
                   | /* vacío */
                   ;

/* ========== Sentencias (dentro de funciones/procedures) ========== */
sentencias ::= sentencia
             | sentencias sentencia
             ;

sentencia ::=
    IDENTIFICADOR:id ASIGNACION expresion PUNTO_COMA
    {:
        // Línea del identificador
        java_cup.runtime.Symbol idSym =
            (java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3);
        int line = (idSym.left >= 0 ? idSym.left + 1 : 1);

        // Resultado de la expresión en la pila semántica
        SemanticStack.StackEntry expr = null;
        if (SemanticStack.size() > 0) {
            expr = SemanticStack.pop();
        }

        // Buscar la variable en la tabla de símbolos
        SymbolTable.Symbol sym = SymbolTable.lookup(id);
        if (sym == null) {
            SemanticAnalyzer.addError(
                line,
                "Variable '" + id + "' no esta definida en un ambito visible",
                "VAR_NO_DEFINIDA"
            );
        } else if (expr != null && !expr.type.equals("ERROR")) {
            // Compatibilidad simple de tipos
            boolean compatible =
                   sym.type.equals(expr.type)
                || (sym.type.equals("REAL") && expr.type.equals("INT")); // INT -> REAL permitido

            if (!compatible) {
                SemanticAnalyzer.addError(
                    line,
                    "Tipos incompatibles en asignacion: no se puede asignar " +
                    expr.type + " a variable de tipo " + sym.type,
                    "TIPOS_INCOMPATIBLES"
                );
            } else {
                // Código intermedio: id = expr.value
                CodeGenerator.emitCode(id + " = " + expr.value);
            }
        }
    :}
  | estructura_control
  | llamada_funcion PUNTO_COMA
  | read_stmt
  | write_stmt
  | IDENTIFICADOR:id INCREMENTO PUNTO_COMA
    {:
        java_cup.runtime.Symbol idSym =
            (java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2);
        int line = (idSym.left >= 0 ? idSym.left + 1 : 1);

        SymbolTable.Symbol sym = SymbolTable.lookup(id);
        if (sym == null) {
            SemanticAnalyzer.addError(
                line,
                "Variable '" + id + "' no esta definida para incremento",
                "VAR_NO_DEFINIDA"
            );
        }
    :}
  | IDENTIFICADOR:id DECREMENTO PUNTO_COMA
    {:
        java_cup.runtime.Symbol idSym =
            (java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2);
        int line = (idSym.left >= 0 ? idSym.left + 1 : 1);

        SymbolTable.Symbol sym = SymbolTable.lookup(id);
        if (sym == null) {
            SemanticAnalyzer.addError(
                line,
                "Variable '" + id + "' no esta definida para decremento",
                "VAR_NO_DEFINIDA"
            );
        }
    :}
  | error PUNTO_COMA
    {: parser.report_error("Error en sentencia. Verifique asignaciones, llamadas a funciones o estructuras de control", null); :}
  ;

/* ========== Cuerpo del Main ========== */
cuerpo_main ::= BEGIN sentencias_main END
              | BEGIN END
              | error sentencias_main END
                {: parser.report_error("Error en el cuerpo del programa principal", null); :}
              | error END
                {: parser.report_error("Error en el cuerpo del programa principal", null); :}
              | BEGIN sentencias_main error
                {: parser.report_error("Error en el cuerpo del programa principal", null); :}
              | BEGIN error
                {: parser.report_error("Error en el cuerpo del programa principal", null); :}
              ;

sentencias_main ::= sentencia_main
                  | sentencias_main sentencia_main
                  ;

sentencia_main ::=
    IDENTIFICADOR:id ASIGNACION expresion PUNTO_COMA
    {:
        java_cup.runtime.Symbol idSym =
            (java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3);
        int line = (idSym.left >= 0 ? idSym.left + 1 : 1);

        // Resultado de la expresión en la pila semántica
        SemanticStack.StackEntry expr = null;
        if (SemanticStack.size() > 0) {
            expr = SemanticStack.pop();
        }

        // Buscar la variable en la tabla de símbolos
        SymbolTable.Symbol sym = SymbolTable.lookup(id);
        if (sym == null) {
            SemanticAnalyzer.addError(
                line,
                "Variable '" + id + "' no esta definida en un ambito visible",
                "VAR_NO_DEFINIDA"
            );
        } else if (expr != null && !expr.type.equals("ERROR")) {
            boolean compatible =
                   sym.type.equals(expr.type)
                || (sym.type.equals("REAL") && expr.type.equals("INT"));

            if (!compatible) {
                SemanticAnalyzer.addError(
                    line,
                    "Tipos incompatibles en asignacion: no se puede asignar " +
                    expr.type + " a variable de tipo " + sym.type,
                    "TIPOS_INCOMPATIBLES"
                );
            } else {
                CodeGenerator.emitCode(id + " = " + expr.value);
            }
        }
    :}
  | estructura_control
  | llamada_funcion PUNTO_COMA
  | read_stmt
  | write_stmt
  | IDENTIFICADOR:id INCREMENTO PUNTO_COMA
    {:
        java_cup.runtime.Symbol idSym =
            (java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2);
        int line = (idSym.left >= 0 ? idSym.left + 1 : 1);

        SymbolTable.Symbol sym = SymbolTable.lookup(id);
        if (sym == null) {
            SemanticAnalyzer.addError(
                line,
                "Variable '" + id + "' no esta definida para incremento",
                "VAR_NO_DEFINIDA"
            );
        }
    :}
  | IDENTIFICADOR:id DECREMENTO PUNTO_COMA
    {:
        java_cup.runtime.Symbol idSym =
            (java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2);
        int line = (idSym.left >= 0 ? idSym.left + 1 : 1);

        SymbolTable.Symbol sym = SymbolTable.lookup(id);
        if (sym == null) {
            SemanticAnalyzer.addError(
                line,
                "Variable '" + id + "' no esta definida para decremento",
                "VAR_NO_DEFINIDA"
            );
        }
    :}
  | funcion_global
  | procedure_global
  | error PUNTO_COMA
    {: parser.report_error("Error en sentencia del programa principal", null); :}
  ;

/* ========== EXPRESIONES ARITMETICAS ========== */
expresion ::= expresion MAS termino
              {: SemanticStack.processBinaryOp("+"); :}
            | expresion MENOS termino
              {: SemanticStack.processBinaryOp("-"); :}
            | termino
            ;

termino   ::= termino POR factor
              {: SemanticStack.processBinaryOp("*"); :}
            | termino DIVISION factor
              {: SemanticStack.processBinaryOp("/"); :}
            | termino DIV factor
              {: SemanticStack.processBinaryOp("DIV"); :}
            | termino MOD factor
              {: SemanticStack.processBinaryOp("MOD"); :}
            | factor
            ;

/* Aquí viene el factor actualizado */
factor ::= PARENTESIS_IZQ expresion PARENTESIS_DER
         | IDENTIFICADOR:id
           {:
               // línea del identificador
               java_cup.runtime.Symbol idSym =
                   (java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-0);
               int line = (idSym.left >= 0 ? idSym.left + 1 : 1);

               // usar SemanticStack para verificar y pushear
               SemanticStack.loadVariable(id, line);
           :}
         | llamada_funcion
         | LIT_ENTERO:ent
           {:
               // Literal entero como constante INT
               SemanticStack.loadConstant("INT", ent.toString());
           :}
         | LIT_REAL:real
           {:
               // Literal real como constante REAL
               SemanticStack.loadConstant("REAL", real.toString());
           :}
         | LIT_STRING:st
           {:
               // Literal string (no hacemos folding, pero queda marcado constante)
               SemanticStack.loadConstant("STRING", st.toString());
           :}
         | LIT_CHAR:ch
           {:
               SemanticStack.loadConstant("CHAR", ch.toString());
           :}
         /* si querés, puedes tratar OCTAL/HEX como INT también */
         | LIT_OCTAL:oct
           {:
               SemanticStack.loadConstant("INT", oct.toString());
           :}
         | LIT_HEX:hex
           {:
               SemanticStack.loadConstant("INT", hex.toString());
           :}
         | MENOS factor
           {:
               // operador unario - (negación)
               SemanticStack.processUnaryOp("-");
           :}
         | MAS factor
           {:
               // + unario → lo ignoramos (no cambia el valor)
           :}
         | IDENTIFICADOR:id INCREMENTO
         | IDENTIFICADOR:id DECREMENTO
         | INCREMENTO IDENTIFICADOR:id
         | DECREMENTO IDENTIFICADOR:id
         ;

/* ========== EXPRESIONES BOOLEANAS (CONDICIONES) ========== */
condicion ::= condicion OR condicion_and
            | condicion_and
            ;

condicion_and ::= condicion_and AND condicion_not
                | condicion_not
                ;

condicion_not ::= NOT condicion_not
                | condicion_relacional
                ;

condicion_relacional ::= expresion IGUAL expresion
                         {: SemanticStack.processRelationalOp("="); :}
                       | expresion DIFERENTE expresion
                         {: SemanticStack.processRelationalOp("<>"); :}
                       | expresion MENOR expresion
                         {: SemanticStack.processRelationalOp("<"); :}
                       | expresion MAYOR expresion
                         {: SemanticStack.processRelationalOp(">"); :}
                       | expresion MENOR_IGUAL expresion
                         {: SemanticStack.processRelationalOp("<="); :}
                       | expresion MAYOR_IGUAL expresion
                         {: SemanticStack.processRelationalOp(">="); :}
                       | PARENTESIS_IZQ condicion PARENTESIS_DER
                       ;

/* ========== ESTRUCTURAS DE CONTROL ========== */
estructura_control ::= while_stmt
                     | for_stmt
                     | if_stmt
                     ;

while_stmt ::= WHILE condicion DO BEGIN sentencias_main END
    {:
        // Verificar que la condición sea de tipo BOOL
        SemanticStack.StackEntry cond = null;
        if (SemanticStack.size() > 0) {
            cond = SemanticStack.pop();
        }

        if (cond != null && !cond.type.equals("BOOL") && !cond.type.equals("ERROR")) {
            java_cup.runtime.Symbol whileSym =
                (java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5);
            int line = (whileSym.left >= 0 ? whileSym.left + 1 : 1);

            SemanticAnalyzer.addError(
                line,
                "La condicion del WHILE debe ser de tipo BOOL",
                "CONDICION_NO_BOOLEANA"
            );
        }
    :}
             | WHILE condicion error BEGIN sentencias_main END
               {: parser.report_error("Error en la estructura del WHILE", null); :}
             | WHILE condicion DO error END
               {: parser.report_error("Error en la estructura del WHILE", null); :}
             | WHILE error DO BEGIN sentencias_main END
               {: parser.report_error("Error en la estructura del WHILE", null); :}
             ;

for_stmt ::= FOR IDENTIFICADOR ASIGNACION expresion TO expresion DO BEGIN sentencias_main END
           | FOR IDENTIFICADOR error expresion TO expresion DO BEGIN sentencias_main END
             {: parser.report_error("Falta ':=' en FOR. Formato: 'FOR variable := inicio TO fin DO BEGIN ... END'", null); :}
           | FOR IDENTIFICADOR ASIGNACION expresion error expresion DO BEGIN sentencias_main END
             {: parser.report_error("Falta TO en FOR. Formato: 'FOR variable := inicio TO fin DO BEGIN ... END'", null); :}
           | FOR IDENTIFICADOR ASIGNACION expresion TO expresion error BEGIN sentencias_main END
             {: parser.report_error("Falta DO en FOR. Formato: 'FOR variable := inicio TO fin DO BEGIN ... END'", null); :}
           | FOR IDENTIFICADOR ASIGNACION expresion TO expresion DO error END
             {: parser.report_error("Falta BEGIN en cuerpo de FOR", null); :}
           | FOR error DO BEGIN sentencias_main END
             {: parser.report_error("Error en declaracion de FOR. Formato: 'FOR variable := inicio TO fin DO BEGIN ... END'", null); :}
           ;

if_stmt ::= IF condicion THEN BEGIN sentencias_main END
    {:
        SemanticStack.StackEntry cond = null;
        if (SemanticStack.size() > 0) {
            cond = SemanticStack.pop();
        }

        if (cond != null && !cond.type.equals("BOOL") && !cond.type.equals("ERROR")) {
            java_cup.runtime.Symbol ifSym =
                (java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-5);
            int line = (ifSym.left >= 0 ? ifSym.left + 1 : 1);

            SemanticAnalyzer.addError(
                line,
                "La condicion del IF debe ser de tipo BOOL",
                "CONDICION_NO_BOOLEANA"
            );
        }
    :}
          | IF condicion THEN BEGIN sentencias_main END ELSE BEGIN sentencias_main END
    {:
        SemanticStack.StackEntry cond = null;
        if (SemanticStack.size() > 0) {
            cond = SemanticStack.pop();
        }

        if (cond != null && !cond.type.equals("BOOL") && !cond.type.equals("ERROR")) {
            java_cup.runtime.Symbol ifSym =
                (java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-9);
            int line = (ifSym.left >= 0 ? ifSym.left + 1 : 1);

            SemanticAnalyzer.addError(
                line,
                "La condicion del IF debe ser de tipo BOOL",
                "CONDICION_NO_BOOLEANA"
            );
        }
    :}
          | IF error BEGIN sentencias_main END
            {: parser.report_error("Error en la estructura del IF", null); :}
          | IF condicion THEN error sentencias_main END
            {: parser.report_error("Error en la estructura del IF", null); :}
          | IF condicion THEN BEGIN sentencias_main error
            {: parser.report_error("Error en la estructura del IF", null); :}
          | IF condicion THEN BEGIN sentencias_main END ELSE BEGIN error END
            {: parser.report_error("Error en la estructura del IF ELSE", null); :}
          | IF condicion THEN BEGIN sentencias_main END ELSE error sentencias_main END
            {: parser.report_error("Error en la estructura del IF ELSE", null); :}
          ;

/* ========== READ Y WRITE ========== */
read_stmt ::=
      READ PARENTESIS_IZQ PARENTESIS_DER PUNTO_COMA
    | READ PARENTESIS_IZQ IDENTIFICADOR:id PARENTESIS_DER PUNTO_COMA
      {:
          java_cup.runtime.Symbol idSym =
              (java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2);
          int line = (idSym.left >= 0 ? idSym.left + 1 : 1);

          SymbolTable.Symbol sym = SymbolTable.lookup(id);
          if (sym == null) {
              SemanticAnalyzer.addError(
                  line,
                  "Variable '" + id + "' usada en READ no esta definida",
                  "VAR_NO_DEFINIDA"
              );
          }
      :}
    | READ PARENTESIS_IZQ IDENTIFICADOR COMA error PARENTESIS_DER PUNTO_COMA
        {: parser.report_error("Error: 'READ' solo acepta una variable. Formato correcto: READ(variable);", null); :}
    | READ PARENTESIS_IZQ error PARENTESIS_DER PUNTO_COMA
        {: parser.report_error("Argumento inválido en READ. Use un identificador de variable", null); :}
    | READ error PUNTO_COMA
        {: parser.report_error("Falta '(' después de READ. Formato: 'READ();' o 'READ(variable);'", null); :}
    | READ PARENTESIS_IZQ IDENTIFICADOR error PUNTO_COMA
        {: parser.report_error("Falta ')' después del identificador en READ", null); :}
    ;


write_stmt ::= WRITE PARENTESIS_IZQ lista_expresiones PARENTESIS_DER PUNTO_COMA
             | WRITE PARENTESIS_IZQ error PARENTESIS_DER PUNTO_COMA
               {: parser.report_error("Expresion invalida en WRITE, debe tener por lo menos un parametro. Use expresiones, variables o literales", null); :}
             | WRITE error PUNTO_COMA
               {: parser.report_error("Falta '(' despues de WRITE. Formato: 'WRITE(exp1, exp2, ...);'", null); :}
             ;

/* ========== LLAMADAS A FUNCIONES ========== */
llamada_funcion ::=
    IDENTIFICADOR:id PARENTESIS_IZQ lista_expresiones PARENTESIS_DER
    {:
        java_cup.runtime.Symbol idSym =
            (java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-3);
        int line = (idSym.left >= 0 ? idSym.left + 1 : 1);

        SymbolTable.Symbol sym = SymbolTable.lookupInScope(id, "GLOBAL");
        if (sym == null || 
            !(sym.category.equals("FUNCTION") || sym.category.equals("PROCEDURE"))) {
            SemanticAnalyzer.addError(
                line,
                "Llamada a '" + id + "' que no esta definida como funcion o procedimiento",
                "FUNCION_NO_DEFINIDA"
            );
        }
        // Más adelante aquí vamos a verificar número y tipos de parámetros
    :}
  | IDENTIFICADOR:id PARENTESIS_IZQ PARENTESIS_DER
    {:
        java_cup.runtime.Symbol idSym =
            (java_cup.runtime.Symbol) CUP$Parser$stack.elementAt(CUP$Parser$top-2);
        int line = (idSym.left >= 0 ? idSym.left + 1 : 1);

        SymbolTable.Symbol sym = SymbolTable.lookupInScope(id, "GLOBAL");
        if (sym == null || 
            !(sym.category.equals("FUNCTION") || sym.category.equals("PROCEDURE"))) {
            SemanticAnalyzer.addError(
                line,
                "Llamada a '" + id + "' que no esta definida como funcion o procedimiento",
                "FUNCION_NO_DEFINIDA"
            );
        }
        // Aquí también usaremos info de parámetros en Fase 2B
    :}
  ;
lista_expresiones ::= expresion mas_expresiones
                    ;

mas_expresiones ::= COMA expresion mas_expresiones
                  | /* vacío */
                  ;

/* ========== TIPOS DE DATOS ========== */
tipo ::= INT
       {: RESULT = "INT"; :}
       | CHAR
       {: RESULT = "CHAR"; :}
       | REAL
       {: RESULT = "REAL"; :}
       | STRING
       {: RESULT = "STRING"; :}
       ;